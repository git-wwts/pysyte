The paths module
================

    >>> import paths

We'll need the os module for some of the tests below

    >>> import os

The pwd() method is a synonym for os.getcwd()

    >>> start_here = paths.pwd()
    >>> start_here == os.getcwd()
    True

The cd() method (at least) calls os.chdir()
It returns True if the change of directory is successful

    >>> paths.cd('/no/such/path')
    False
    >>> paths.pwd() == '/usr/lib'
    False
    >>> paths.cd('/usr/lib')
    True
    >>> paths.pwd()
    <DirectPath u'/usr/lib'>

cd() recognises the special value '-' to go back to the previous directory

    >>> paths.cd('-') and paths.pwd() == start_here or 'fail'
    True

If a cd() fails the value used gets ignored for going back
    >>> paths.cd('/no/such/path') and paths.pwd() or 'fail'
    'fail'
    >>> paths.cd('-') and paths.pwd() or 'fail'
    <DirectPath u'/usr/lib'>

Calling using '-' repeatedly will toggle between two directories:

    >>> paths.cd('/usr')
    True
    >>> paths.cd('/home')
    True
    >>> for i in range(0,4):
    ...    _ = paths.cd('-')
    ...    print paths.pwd()
    /usr
    /home
    /usr
    /home

If the path to a file is given, cd() will change to that file's parent directory

    >>> paths.cd('/bin/cp')
    True
    >>> paths.pwd() == '/bin'
    True

DirectPath
----------

A class called DirectPath is also supplied, which extends the path class, slightly.
You can construct an instance of DirectPath directly:

    >>> p = paths.DirectPath('.')

Or by using the method makepath

    >>> p = makepath('.')

The difference is that makepath expands the string given
    >>> paths.DirectPath('~/..')[0] == '~'
    True
    >>> makepath('~/..')[0] == '/'
    True

DirectPath is ako string, which shows the string in %s and %r

    >>> bin = paths.DirectPath('/bin')
    >>> print '%s' % bin
    /bin
    >>> print '%r' % bin
    <DirectPath u'/bin'>

Path expansion at creation
--------------------------

The makepath method expands paths "normally"
    So both of these end up with the same (string) value:
    >>> direct_home = paths.DirectPath(os.environ['HOME'])
    >>> path_to_home = makepath('~')
    >>> direct_home == path_to_home
    True
    
And that is an expanded path
    >>> path_to_home.startswith('/') and '~' not in path_to_home
    True

The same works for the value if concatenation was applied to the path
    or is applied to the string
    >>> path_to_bashrc = makepath('~/.bashrc')
    >>> path_to_home / '.bashrc' == path_to_bashrc
    True

We are expecting ~/.bashrc to exist,
    so the types should also be the same: both are FilePaths
    >>> type(path_to_home / '.bashrc') == type(path_to_bashrc)
    True

cd
--

DirectPath adds the cd() method, which cd's to the path it represents
It calls the module level cd() method with its own value, so it works as above.

    >>> p = makepath('/bin/cp')
    >>> p.cd()
    True
    >>> paths.pwd() == '/bin'
    True
    >>> f = paths.DirectPath('/bin')
    >>> f.cd() and paths.pwd() or 'fail'
    <DirectPath u'/bin'>

DirectPath vs path
------------------

Using the / operator on a DirectPath or path gives an instance of the same class
    >>> from path import path
    >>> home = path('~')
    >>> bashrc = home / '.bashrc'
    >>> type(bashrc)
    <class 'path.path'>

    >>> home = paths.DirectPath('~')
    >>> bashrc = home / '.bashrc'
    >>> type(bashrc)
    <class 'paths.DirectPath'>

Attributes of a DirectPath should also be DirectPaths (should not be path)
    >>> type(bashrc.parent)
    <class 'paths.DirectPath'>

The split_all_ext method
------------------------

    >>> p = paths.FilePath('/alan/was/here.tar.gz')
    >>> p.splitext()
    (<FilePath u'/alan/was/here.tar'>, u'.gz')
    >>> p.split_all_ext()
    (<FilePath u'/alan/was/here'>, u'.tar.gz')


Whether sub_paths exist
-----------------------

This test assumes you have a ~/bin directory
    Also assumes you have a ~/.bashrc file, which is more likely
    >>> sub_paths = [ '.bashrc', 'bin', 'not a real path' ]
    >>> real_paths = paths.home().existing_sub_paths(sub_paths)
    >>> show(real_paths)
    [<FilePath u'/.../.bashrc'>, <DirectPath u'/.../bin'>]

Iteration of paths
------------------

Iterating a directory gives directory entries (sub-directories and files)
    >>> '.bashrc' in [p.name for p in paths.home() if p.isfile()]
    True

Iterating a file gives lines
    >>> p = paths.home() / '.bashrc'
    >>> print [l for l in p if 'source' in l][0]
    source ...
