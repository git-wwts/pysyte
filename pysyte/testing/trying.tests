Testing the try script
===========================

try
---

try is a reserved word so we need a roundabout import
    >>> from pysyte.testing import trying

try.tests
---------

There is more text in here than I'd normally use in *.tests
But doctest got verbose when I called it *.test, showing:
    *** DocTestRunner.merge: 'try.test' in both testers; summing outcomes.

Assuming that this test is actually run under try
    otherwise the next line will crash

Running tests with try provides an instance called test
    which has some interesting attributes
    e.g. this file is called try.tests
    >>> assert test.path.name == 'trying.tests'

If that went well we have a hidden variable called test
    which is an object from the __main__ module
    and has some attributes

    >>> assert test.path_to_py.name == 'trying.py'

    >>> import os
    >>> assert test.here == os.getcwd()

We also have access to some modules I often use
    without a need for explicit import
    Which ignores the heuristic that
        "Explicit is better than implicit"
    >>> assert test.path.name == makepath(sys.argv[0]).name

And we can run bash commands
    >>> assert bash('/bin/ls ~/.bashrc')
    /.../.bashrc

    >>> assert test.home == makepath('~')

We know the user who is running the tests
    >>> assert test.user == '%s@%s' % (os.environ['USER'], test.host)

Edge cases
----------

    >>> assert not bash('/bin/ls ~/no_such_file')
    FAIL: .../no_such_file: No such file or directory

    >>> show(os)
    Help on module os:
    ...

    >>> show(0)
    0

    >>> re_imported_try = trying.make_module(test.path_to_py)
    >>> assert re_imported_try.__file__ == trying.__file__

    >>> import see
    >>> assert see == trying.make_module(test.path_to_py.parent / 'see.py')
    >>> show(see)
    Help on module see:
    ...
        /.../testing/see.py
    ...

    >>> del sys.modules['see']
    >>> see = trying.make_module(test.path_to_py.parent / 'see.py')
    >>> show(see)
    Help on module see:
    ...
        /.../testing/see.py
    ...
    >>> mod = trying.make_module(test.path_to_py.parent / 'not_a_file.py')
    >>> assert isinstance(mod, type(trying))
    >>> assert mod.__name__, 'not_a_file'
